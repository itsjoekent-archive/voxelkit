import fs from 'fs/promises';
import path from 'path';
import { camelCase, pascalCase } from 'change-case';
import dedent from 'dedent';
import { compile } from 'json-schema-to-typescript';
import { LanguageCode } from '@services/translations/helpers';

// THIS FILE IS ONLY FOR GENERATING TRANSLATIONS IN LOCAL DEVELOPMENT & CI/CD.
// DO NOT IMPORT THIS FILE AS PART OF THE RUNTIME.

// TODO: Call Google Translate API
// TODO: Create init function to get all collections and either compile once or watch based on env

async function translationsGenerator(collectionName: string) {
  const collectionPath = path.join(
    __dirname,
    'collections',
    `${collectionName}.json`
  );

  const collectionJson = await fs.readFile(collectionPath, 'utf-8');
  const collection = JSON.parse(collectionJson);

  let generatedFile = dedent`
  // THIS FILE IS AUTOMATICALLY GENERATED BY TRANSLATIONS/GENERATOR.TS
  // DO NOT EDIT THIS FILE DIRECTLY.
  
  import { LanguageCode, translateCopy } from '@services/translations/helpers';\n\n`;

  for (const phraseId of Object.keys(collection)) {
    let collectionValue = collection[phraseId];

    if (typeof collectionValue === 'string') {
      collectionValue = { phrase: collectionValue };
    }

    const { phrase, args } = collectionValue;

    if (!phrase) {
      console.error(`Phrase "${phraseId}" has no phrase property`);
      continue;
    }

    const totalVars = phrase.match(/{{var}}/g)?.length ?? 0;
    if (
      (!!totalVars && (!args || !Array.isArray(args))) ||
      (totalVars > 0 && totalVars !== args?.length)
    ) {
      console.error(`Phrase "${phraseId}" has not specified all args`);
      continue;
    }

    const dictionary: Partial<
      Record<LanguageCode | `${LanguageCode}-plural`, string>
    > = {
      'en-us': phrase,
    };

    if (phrase.includes('{{plural}}')) {
      dictionary['en-us'] = phrase.replaceAll('{{plural}}', '');
      dictionary['en-us-plural'] = phrase.replaceAll('{{plural}}', "'s");
    }

    const functionName = camelCase(`${phraseId}`);
    const futureFunctionName = camelCase(`${phraseId}Ref`);
    const dictionaryStringified = JSON.stringify(dictionary);

    if (totalVars === 0) {
      const translationFunction = dedent`
        export function ${functionName}(language: LanguageCode): string {
          return translateCopy(
            ${dictionaryStringified},
            language,
          );
        }

        export function ${futureFunctionName}() {
          return ${functionName};
        }
      `;

      generatedFile += translationFunction + '\n\n';
      continue;
    }

    const tsTitle = `Phrase${pascalCase(phraseId)}Args`;

    const tsProperties = Array.isArray(args)
      ? args.reduce((acc, arg) => {
          if (
            !arg.name ||
            typeof arg.name !== 'string' ||
            typeof arg.type !== 'string'
          ) {
            return acc;
          }

          acc[arg.name] = {
            type: arg.type,
          };
          return acc;
        }, {})
      : {};

    const tsRequired = Array.isArray(args)
      ? args.filter((arg) => arg.required).map((arg) => arg.name)
      : [];

    const tsSchema = await compile(
      {
        title: tsTitle,
        type: 'object',
        properties: tsProperties,
        additionalProperties: false,
        required: tsRequired,
      },
      tsTitle
    );

    const argsOrder = Array.isArray(args) ? args.map((arg) => arg.name) : [];

    const pluralizer = Array.isArray(args)
      ? args.find((arg) => arg.pluralizer)?.name || null
      : null;

    const translationFunction = dedent`
      export function ${functionName}(language: LanguageCode, args: ${tsTitle}): string {
        return translateCopy<${tsTitle}>(
          ${dictionaryStringified},
          language,
          args, 
          ${JSON.stringify(argsOrder)}, 
          ${JSON.stringify(pluralizer)},
        );
      }

      export function ${futureFunctionName}(args: ${tsTitle}) {
        return (language: LanguageCode) => ${functionName}(language, args);
      }
    `;

    const code = `${tsSchema}\n${translationFunction}\n`;
    generatedFile += code;
  }

  await fs.writeFile(
    path.join(__dirname, `generated/${collectionName}.ts`),
    generatedFile
  );
}

translationsGenerator('accounts');
translationsGenerator('system');
translationsGenerator('validation');
