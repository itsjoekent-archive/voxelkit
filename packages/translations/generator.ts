// THIS FILE IS ONLY FOR GENERATING TRANSLATIONS IN LOCAL DEVELOPMENT & CI/CD.
// DO NOT IMPORT THIS FILE AS PART OF THE RUNTIME.

import fs from 'fs/promises';
import path from 'path';
import { camelCase, pascalCase } from 'change-case';
import { watch } from 'chokidar';
import dedent from 'dedent';
import { compile } from 'json-schema-to-typescript';
import { v2 as GcpTranslateV2 } from '@google-cloud/translate';
import { LanguageCode, languages } from './src/helpers';

const { Translate } = GcpTranslateV2;
const translate = new Translate();

async function translationsGenerator(collectionName: string) {
  console.log(`Generating translations for ${collectionName}`);

  const collectionPath = path.join(
    __dirname,
    'collections',
    `${collectionName}.json`
  );

  const collectionJson = await fs.readFile(collectionPath, 'utf-8');
  const collection = JSON.parse(collectionJson);

  let generatedFile = dedent`
  // THIS FILE IS AUTOMATICALLY GENERATED BY TRANSLATIONS/GENERATOR.TS
  // DO NOT EDIT THIS FILE DIRECTLY.

  import { LanguageCode, translateCopy } from '../helpers';\n\n`;

  for (const phraseId of Object.keys(collection)) {
    let collectionValue = collection[phraseId];

    if (typeof collectionValue === 'string') {
      collectionValue = { phrase: collectionValue };
    }

    const { phrase, args } = collectionValue;

    if (!phrase) {
      console.error(`Phrase "${phraseId}" has no phrase property`);
      continue;
    }

    const totalVars = phrase.match(/{{var}}/g)?.length ?? 0;
    if (
      (!!totalVars && (!args || !Array.isArray(args))) ||
      (totalVars > 0 && totalVars !== args?.length)
    ) {
      console.error(`Phrase "${phraseId}" has not specified all args`);
      continue;
    }

    const dictionary: { 'en-US': string } & Partial<
      Record<LanguageCode | `${LanguageCode}-plural`, string>
    > = {
      'en-US': phrase,
    };

    if (phrase.includes('{{plural}}')) {
      dictionary['en-US'] = phrase.replaceAll('{{plural}}', '');
      dictionary['en-US-plural'] = phrase.replaceAll('{{plural}}', "'s");
    }

    for (const language of languages) {
      if (language === 'en-US') continue;

      const translation = await translate.translate(
        dictionary['en-US'],
        language
      );
      dictionary[language] = translation[0];

      if (dictionary['en-US-plural']) {
        const pluralTranslation = await translate.translate(
          dictionary['en-US-plural'],
          language
        );
        dictionary[`${language}-plural`] = pluralTranslation[0];
      }
    }

    const functionName = camelCase(`${phraseId}`);
    const futureFunctionName = camelCase(`${phraseId}Ref`);
    const dictionaryStringified = JSON.stringify(dictionary);

    if (totalVars === 0) {
      const translationFunction = dedent`
        export function ${functionName}(language: LanguageCode = 'en-US'): string {
          return translateCopy(
            ${dictionaryStringified},
            language,
          );
        }

        export function ${futureFunctionName}() {
          return ${functionName};
        }
      `;

      generatedFile += translationFunction + '\n\n';
      continue;
    }

    const tsTitle = `Phrase${pascalCase(phraseId)}Args`;

    const tsProperties = Array.isArray(args)
      ? args.reduce((acc, arg) => {
          if (
            !arg.name ||
            typeof arg.name !== 'string' ||
            typeof arg.type !== 'string'
          ) {
            return acc;
          }

          acc[arg.name] = {
            type: arg.type,
          };
          return acc;
        }, {})
      : {};

    const tsRequired = Array.isArray(args)
      ? args.filter((arg) => arg.required).map((arg) => arg.name)
      : [];

    const tsSchema = await compile(
      {
        title: tsTitle,
        type: 'object',
        properties: tsProperties,
        additionalProperties: false,
        required: tsRequired,
      },
      tsTitle
    );

    const argsOrder = Array.isArray(args) ? args.map((arg) => arg.name) : [];

    const pluralizer = Array.isArray(args)
      ? args.find((arg) => arg.pluralizer)?.name || null
      : null;

    const translationFunction = dedent`
      export function ${functionName}(language: LanguageCode = 'en-US', args: ${tsTitle}): string {
        return translateCopy<${tsTitle}>(
          ${dictionaryStringified},
          language,
          args,
          ${JSON.stringify(argsOrder)},
          ${JSON.stringify(pluralizer || undefined)},
        );
      }

      export function ${futureFunctionName}(args: ${tsTitle}) {
        return (language: LanguageCode) => ${functionName}(language, args);
      }
    `;

    const code = `${tsSchema}\n${translationFunction}\n`;
    generatedFile += code;
  }

  await fs.writeFile(
    path.join(__dirname, `src/generated/${collectionName}.ts`),
    generatedFile
  );
}

async function writeIndexFile(collectionNames: string[]) {
  console.log(`Generating translations index file`);

  const indexFilePath = path.join(__dirname, 'src/index.ts');
  const indexFile = dedent`
  // THIS FILE IS AUTOMATICALLY GENERATED BY TRANSLATIONS/GENERATOR.TS
  // DO NOT EDIT THIS FILE DIRECTLY.

  export { LanguageCode, languages, defaultLanguage } from './helpers';
  ${collectionNames
    .map((collection) => `export * from './generated/${collection}';`)
    .join('\n')}
  `;

  await fs.writeFile(indexFilePath, indexFile);
}

(async () => {
  const collectionsDirectory = path.join(__dirname, 'collections');
  const collections = await fs.readdir(collectionsDirectory);
  const allCollectionNames = collections.map((collectionFileName) =>
    collectionFileName.replace('.json', '')
  );

  if (process.env.WATCH !== 'true') {
    console.log('Generating translations for all collections');
    await Promise.all(
      allCollectionNames.map((collection) => translationsGenerator(collection))
    );

    await writeIndexFile(allCollectionNames);
    process.exit(0);
  }

  console.log('Watching translations for changes...');
  watch(collectionsDirectory).on('all', async (event, filepath) => {
    if (event === 'addDir') return;
    const collectionName = filepath.split('/').pop()?.replace('.json', '');
    console.log(collectionName);
    if (collectionName) {
      await translationsGenerator(collectionName);
      await writeIndexFile(allCollectionNames);
    }
  });
})();
